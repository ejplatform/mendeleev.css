// Functions in this package will eventually make their way to fn.sass.
@import '../node_modules/fn.sass/src/fn';

/// Log given $values and return the last argument.
@function log($args...) {
    @warn 'LOG: #{$args}';
    @return nth($args, length($args));
}

/// Intercalate elements of both lists
///
/// @arg $xs - First list
/// @arg $ys - Second list
@function lst-intercalate($xs, $ys) {
    $xs: to-lst($xs);
    $ys: to-lst($ys);
    $res: null;
    @while $xs != null and $ys != null {
        $x: car($xs);
        $xs: cdr($xs);
        $y: car($ys);
        $ys: cdr($ys);
        $res: cons($y, cons($x, $res));
        @if $xs == null {
            @return lst-stitch($res, $ys)
        }
        @if $ys == null {
            @return lst-stitch($res, $xs)
        }
    }
    @return lst-reverse($res);
}

/// Create a list of pairs of (position value).
///
/// @arg $xs - Input list
/// @arg $start - Optional starting value (begins with 1)
/// @arg $step - Optional step (1 if not given)
@function lst-enumerate($xs, $start: 1, $step: 1, $reverse: false) {
    $xs: to-lst($xs);
    $res: null;
    @while $xs != null {
        $x: car($xs);
        $xs: cdr($xs);
        $res: cons(($start $x), $res);
        $start: $start + $step;
    }
    @return if($reverse, $res, lst-reverse($res));
}

$do: assert-eq(lst-intercalate(L(1, 3, 5), L(2, 4, 6)), L(1, 2, 3, 4, 5, 6));
$do: assert-eq(lst-intercalate(L(1, 3), L(2, 4, 6, 8)), L(1, 2, 3, 4, 6, 8));
$do: assert-eq(lst-intercalate(L(1, 3, 5, 7), L(2, 4)), L(1, 2, 3, 4, 5, 7));

$do: assert-eq(lst-enumerate(L('a', 'b', 'c')), L(1 'a', 2 'b', 3 'c'));
$do: assert-eq(lst-enumerate(L('a', 'b', 'c'), $start: 0), L(0 'a', 1 'b', 2 'c'));
$do: assert-eq(lst-enumerate(L('a', 'b', 'c'), $step: 2), L(1 'a', 3 'b', 5 'c'));


@mixin var-fallback($defs) {
    @each $prop, $pair in $defs {
        $value: nth($pair, 1);
        $var-name: nth($pair, 2);
        #{$prop}: #{$value};
        #{$prop}: unquote('var(--#{$var-name})');
    }
}


