//------------------------------------------------------------------------------
// DECLARE MENDELEEV MODULES
//------------------------------------------------------------------------------

$_mendeleev-module-special-decl: unique-id() !default;

//
// AUXILIARY FUNCTIONS
//
@function _mendeleev-module-is-special-decl($data) {
    @return type-of($data) == list and nth($data, 1) == $_mendeleev-module-special-decl;
}

//------------------------------------------------------------------------------
// PUBLIC API FUNCTIONS
//------------------------------------------------------------------------------

/// Declare a Mendeleev module of CSS declarations.
///
/// @arg $cfg - String path for the configuration option in the global
///             Mendeleev config
/// @arg $spec - Dictionary of declarations mapping CSS selector with CSS
///              definitions
@function mendeleev-module($cfg, $spec) {
    $emit: config($cfg);
    $res: null;

    @each $selector, $data in $spec {
        @if type-of($data) == map {
            // Simple utility
            $res: cons(register-utility($selector, $data, $emit), $res);

        } @else if _mendeleev-module-is-special-decl($data) {
            // Special declarations
            $fn: as-func(nth($data, 2));
            $args: nth($data, 4);
            $res: cons(call($fn, $emit, $selector, $args...), $res);

        } @else {
            // Invalid specification
            @error "Invalid content for #{$selector}."
        }
    }
    @return $res;
}

/// Declare a Mendeleev module of CSS utilities. A utility is understood as a
/// CSS declaration that defines a single CSS property.
///
/// This function makes it easier to declare lots of classes in batch, but is
/// far less flexible on the kind of declarations that can be made.
///
/// @arg $cfg - String path for the configuration option in the global
///             Mendeleev config
/// @arg $spec - Dictionary of declarations mapping CSS selector with CSS
///              definitions
@function mendeleev-utility-module($cfg, $spec) {
    $emit: config($cfg);
    $res: null;

    @each $prop, $data in $spec {
        $prefix: nth($data, 1);
        $content: nth($data, 2);

        @if _mendeleev-module-is-special-decl($content) {
            // Special declarations
            $fn: as-func(nth($content, 3));
            $args: nth($content, 4);
            $res: call($fn, $emit, $prop, $prefix, $args...);

        } @else if type-of($content) == map {
            // Simple map based declaration
            @each $suffix, $value in $content {
                $name: '#{$prefix}#{$suffix}';
                $data: (#{$prop}: $value);
                $res: cons(register-utility($name, $data, $emit), $res);
            }

        } @else if type-of($content) == list {
            // Simple list based declaration
            @each $value in $content {
                $name: '#{$prefix}#{$value}';
                $data: (#{$prop}: $value);
                $res: cons(register-utility($name, $data, $emit), $res);
            }
        } @else {
            @error "Invalid specification for #{$prop}."
        }
    }
    @return $res;
}

@function fn-scale($fn, $scale, $args...) {
    @return (
        $_mendeleev-module-special-decl,
        _mendeleev-fn-scale-module-worker,
        _mendeleev-fn-scale-utility-module-worker,
        join(($fn, $scale), $args),
    );
}

@function utility-scale($prop, $name, $value) {
    @return ($name: ($prop: $value));
}

/// Declares a complete scale of values.
@function scale-of($scale, $css: null, $args...) {
    @if $css != null {
        @return fn-scale(_mendeleev-scale-of-template, $scale, $css);
    } @else {
        @error 'You must specify the scale type.'
    }
}

@function utility-scale-of($scale) {
    @return fn-scale(_mendeleev-utility-scale-of, $scale);
}

@function _mendeleev-utility-scale-of($prop, $name, $value) {
    @return ($name: ($prop: $value));
}

@function _mendeleev-scale-fetch-item($scale, $n) {
    $first: car($scale);
    @return if(length($first) == 1, $first, nth($first, $n));
}

@function _mendeleev-scale-of-template($name, $value, $spec) {
    $res: ();
    $value: inspect($value);
    @each $k, $v in $spec {
        $k: str-replace($k, '$1', $value);
        $v: if(type-of($v) == string, unquote(str-replace($v, '$1', $value)), $v);
        $res: map-merge($res, ($k: $v));
    }
    @return ($name: $res);
}

@function _mendeleev-fn-scale-module-worker($emit, $template, $fn, $scale, $args...) {
    $fn: as-func($fn);
    $res: null;

    @if type-of($scale) == map {
        @each $key, $value in $scale {
            $name: str-interpolate($template, $key);
            @each $selector, $spec in call($fn, $name, $value, $args...) {
                $data: register-utility($selector, $spec, $emit);
                $res: cons($data, $res);
            }
        }

    } @else {
        @while $scale != null {
            $key: _mendeleev-scale-fetch-item($scale, 1);
            $value: _mendeleev-scale-fetch-item($scale, 2);
            $scale: cdr($scale);
            $name: str-interpolate($template, $key);
            @each $selector, $spec in call($fn, $name, $value, $args...) {
                $data: register-utility($selector, $spec, $emit);
                $res: cons($data, $res);
            }
        }
    }
    @return $res;
}

@function _mendeleev-fn-scale-utility-module-worker($emit, $prop, $prefix, $fn, $scale, $args...) {
    $fn: as-func($fn);
    $res: null;

    @if type-of($scale) == map {
        @each $key, $value in $scale {
            $name: str-interpolate($prefix, L($key));
            @each $selector, $spec in call($fn, $prop, $name, $value, $args...) {
                $data: register-utility($selector, $spec, $emit);
                $res: cons($data, $res);
            }
        }

    } @else {
        @while $scale != null {
            $key: _mendeleev-scale-fetch-item($scale, 1);
            $value: _mendeleev-scale-fetch-item($scale, 2);
            $scale: cdr($scale);
            $name: str-interpolate($prefix, L($key));
            @each $selector, $spec in call($fn, $prop, $name, $value, $args...) {
                $data: register-utility($selector, $spec, $emit);
                $res: cons($data, $res);
            }
        }
    }

    @return $res;
}
